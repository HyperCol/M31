#version 130

uniform sampler2D composite;
uniform sampler2D colortex7;

uniform sampler2D depthtex0;

in vec2 texcoord;
/*
const bool compositeMipmapEnabled = true;
*/
#include "/libs/setting.glsl"
#include "/libs/uniform.glsl"
#include "/libs/common.glsl"

vec3 RGBToYCoCg(vec3 c) {
	// Y = R/4 + G/2 + B/4
	// Co = R/2 - B/2
	// Cg = -R/4 + G/2 - B/4

    return vec3(c.x/4.0 + c.y/2.0 + c.z/4.0,
                c.x/2.0 - c.z/2.0,
                -c.x/4.0 + c.y/2.0 - c.z/4.0);
}

vec3 YCoCgToRGB(vec3 c) {
	// R = Y + Co - Cg
	// G = Y + Cg
	// B = Y - Co - Cg

    return vec3(c.x + c.y - c.z,
             c.x + c.z,
	         c.x - c.y - c.z);
}

vec4 ReprojectSampler(in sampler2D tex, in vec2 pixelPos){
    vec4 result = vec4(0.0);

    vec2 position = resolution * pixelPos;
    vec2 centerPosition = floor(position - 0.5) + 0.5;

    vec2 f = position - centerPosition;
    vec2 f2 = f * f;
    vec2 f3 = f * f2;

    float c = 0.6 + (TAA_Accumulation_Shapress / 50.0 - 1.0) * 0.2;
    vec2 w0 =         -c  *  f3 + 2.0 * c          *  f2 - c  *  f;
    vec2 w1 =  (2.0 - c)  *  f3 - (3.0 - c)        *  f2            + 1.0;
    vec2 w2 = -(2.0 - c)  *  f3 + (3.0 - 2.0 * c)  *  f2 + c  *  f;
    vec2 w3 =          c  *  f3 - c                *  f2;
    vec2 w12 = w1 + w2;

    vec2 tc12 = texelSize * (centerPosition + w2 / w12);
    vec2 tc0 = texelSize * (centerPosition - 1.0);
    vec2 tc3 = texelSize * (centerPosition + 2.0);

    result =  vec4(texture(tex, vec2(tc12.x, tc0.y)).rgb, 1.0) * (w12.x * w0.y) +
              vec4(texture(tex, vec2(tc0.x, tc12.y)).rgb, 1.0) * (w0.x * w12.y) +
              vec4(texture(tex, vec2(tc12.x, tc12.y)).rgb, 1.0) * (w12.x * w12.y) +
              vec4(texture(tex, vec2(tc3.x, tc12.y)).rgb, 1.0) * (w3.x * w12.y) +
              vec4(texture(tex, vec2(tc12.x, tc3.y)).rgb, 1.0) * (w12.x * w3.y);

    result /= result.a;
    result.rgb = saturate(result.rgb);

    return result;
}

vec3 GetVariance(in vec2 coord, out vec3 minColor, out vec3 maxColor) {
    vec3 m1 = vec3(0.0);
    vec3 m2 = vec3(0.0);

    for(float i = -1.0; i <= 1.0; i += 1.0) {
        for(float j = -1.0; j <= 1.0; j += 1.0) {
            vec3 sampleColor = RGBToYCoCg(textureLod(composite, coord + vec2(i, j) * texelSize, 0).rgb);

            m1 += sampleColor;
            m2 += sampleColor * sampleColor;
        }
    }

    m1 /= 9.0;
    m2 /= 9.0;

    vec3 variance = sqrt(abs(m1 * m1 - m2));

    const float sigma = 2.0;

    minColor = m1 - variance * sigma;
    maxColor = m1 + variance * sigma;

    return variance;
}

vec3 GetClosest(in vec2 coord) {
    vec3 closest = vec3(0.0, 0.0, 1.0);

    for(float i = -1.0; i <= 1.0; i += 1.0) {
        for(float j = -1.0; j <= 1.0; j += 1.0) {
            float depth = texture(depthtex0, coord + vec2(i, j) * texelSize).x;

            if(depth < closest.z) {
                closest = vec3(i, j, depth);
            }
        }
    }

    closest.xy = closest.xy * texelSize + coord;

    return closest;
}
#if 0
vec3 FsrRcasLoadF(in vec2 coord) {
    return RGBToYCoCg(texture(colortex7, coord * texelSize).rgb);
}

#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))

#define FSR_RCAS_DENOISE

void FsrRcasF(
out vec3 pix, // Output values, non-vector so port between RcasFilter() and RcasFilterH() is easy.
vec2 coord, // Integer pixel position in output.
float con){ // Constant generated by RcasSetup().
    // Algorithm uses minimal 3x3 pixel neighborhood.
    //    b 
    //  d e f
    //    h
    vec2 sp = (coord * resolution);
    vec3 b=FsrRcasLoadF(sp + vec2( 0,-1)).rgb;
    vec3 d=FsrRcasLoadF(sp + vec2(-1, 0)).rgb;
    vec3 e=FsrRcasLoadF(sp).rgb;
    vec3 f=FsrRcasLoadF(sp + vec2( 1, 0)).rgb;
    vec3 h=FsrRcasLoadF(sp + vec2( 0, 1)).rgb;
    // Rename (32-bit) or regroup (16-bit).
    float bR=b.r;
    float bG=b.g;
    float bB=b.b;
    float dR=d.r;
    float dG=d.g;
    float dB=d.b;
    float eR=e.r;
    float eG=e.g;
    float eB=e.b;
    float fR=f.r;
    float fG=f.g;
    float fB=f.b;
    float hR=h.r;
    float hG=h.g;
    float hB=h.b;
    // Run optional input transform.
    //FsrRcasInputF(bR,bG,bB);
    //FsrRcasInputF(dR,dG,dB);
    //FsrRcasInputF(eR,eG,eB);
    //FsrRcasInputF(fR,fG,fB);
    //FsrRcasInputF(hR,hG,hB);
    // Luma times 2.
    float bL=bB*float(0.5)+(bR*float(0.5)+bG);
    float dL=dB*float(0.5)+(dR*float(0.5)+dG);
    float eL=eB*float(0.5)+(eR*float(0.5)+eG);
    float fL=fB*float(0.5)+(fR*float(0.5)+fG);
    float hL=hB*float(0.5)+(hR*float(0.5)+hG);
    // Noise detection.
    float nz=float(0.25)*bL+float(0.25)*dL+float(0.25)*fL+float(0.25)*hL-eL;
    nz=saturate(abs(nz)*(1.0 / max(max(bL,max(dL,eL)),max(fL,hL))-min(min(bL,min(dL,eL)),min(fL,hL))));
    nz=float(-0.5)*nz+float(1.0);
    // Min and max of ring.
    float mn4R=min(min(bR,min(dR,fR)),hR);
    float mn4G=min(min(bG,min(dG,fG)),hG);
    float mn4B=min(min(bB,min(dB,fB)),hB);
    float mx4R=max(max(bR,max(dR,fR)),hR);
    float mx4G=max(max(bG,max(dG,fG)),hG);
    float mx4B=max(max(bB,max(dB,fB)),hB);
    // Immediate constants for peak range.
    vec2 peakC=vec2(1.0,-1.0*4.0);
    // Limiters, these need to be high precision RCPs.
    float hitMinR=mn4R/(float(4.0)*mx4R);
    float hitMinG=mn4G/(float(4.0)*mx4G);
    float hitMinB=mn4B/(float(4.0)*mx4B);
    float hitMaxR=(peakC.x-mx4R)/(float(4.0)*mn4R+peakC.y);
    float hitMaxG=(peakC.x-mx4G)/(float(4.0)*mn4G+peakC.y);
    float hitMaxB=(peakC.x-mx4B)/(float(4.0)*mn4B+peakC.y);
    float lobeR=max(-hitMinR,hitMaxR);
    float lobeG=max(-hitMinG,hitMaxG);
    float lobeB=max(-hitMinB,hitMaxB);
    float lobe=max(float(-FSR_RCAS_LIMIT),min(max(lobeR,max(lobeG,lobeB)),float(0.0)))*con;
    // Apply noise removal.
    #ifdef FSR_RCAS_DENOISE
    lobe*=nz;
    #endif
    // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.
    float rcpL=1.0 / (float(4.0)*lobe+float(1.0));
    pix.r=(lobe*bR+lobe*dR+lobe*hR+lobe*fR+eR)*rcpL;
    pix.g=(lobe*bG+lobe*dG+lobe*hG+lobe*fG+eG)*rcpL;
    pix.b=(lobe*bB+lobe*dB+lobe*hB+lobe*fB+eB)*rcpL;
}
#endif
void main() {
    vec3 color = RGBToYCoCg(textureLod(composite, texcoord, 0).rgb);

    vec3 maxColor = vec3( 1.0);
    vec3 minColor = vec3(-1.0);
    vec3 variance = GetVariance(texcoord, minColor, maxColor);

    vec3 closest = GetClosest(texcoord);
    vec2 velocity = GetVelocity(closest);
    if(closest.z < 0.7) velocity *= 0.001;
    float velocityLength = length(velocity * resolution);

    vec2 previousCoord = texcoord - velocity;
    float InScreen = step(max(abs(previousCoord.x - 0.5), abs(previousCoord.y - 0.5)), 0.5);

    vec3 previousColor = RGBToYCoCg(ReprojectSampler(colortex7, previousCoord).rgb);
         previousColor = clamp(previousColor, minColor, maxColor);

    float blend = 0.95 * InScreen;
          blend -= step(0.05, velocityLength) * clamp(rescale(sum3(YCoCgToRGB(variance)), 0.05, 0.5), 0.5, 1.0) * 0.1;

    vec3 antialiased = mix(color, previousColor, vec3(blend));
         antialiased = YCoCgToRGB(antialiased);

    vec3 outputColor = LinearToGamma(antialiased);
         outputColor = -outputColor / (min(vec3(1e-8), outputColor) - 1.0);
         outputColor *= MappingToSDR;
         outputColor = GammaToLinear(outputColor);

    //outputColor = vec3(saturate(step(0.99, hash(floor(texcoord * resolution * 0.125)))));

    vec3 centerSample = textureLod(composite, vec2(0.5), log2(viewHeight)).rgb;

    float exposureCurrent = luminance3(centerSample);
    float exposurePrevious = texture(colortex7, vec2(0.5)).a; if(exposurePrevious < 1e-5) exposurePrevious = exposureCurrent;

    float updateRate = 1.0;
    float counter = mod(frameTimeCounter * updateRate, 1);
    float update = round(counter);

    #if Average_Exposure_PerFrame_Weight == Auto
    float weight = (frameTimeCounter + 1.0) / float(frameCounter + 45);
    //float weight = saturate(counter - mod(frameTimeCounter * updateRate * 0.25, 1));
    #else
    float weight = 1.0 / Average_Exposure_PerFrame_Weight;
    #endif

    float exposureResult = mix(exposurePrevious, exposureCurrent, weight);

    gl_FragData[0] = vec4(outputColor, exposureResult);
    gl_FragData[1] = vec4(antialiased, exposureResult);
}
/* DRAWBUFFERS:37 */