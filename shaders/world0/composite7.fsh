#version 130

uniform sampler2D composite;
uniform sampler2D colortex7;

uniform sampler2D depthtex0;

in vec2 texcoord;

#include "/libs/setting.glsl"
#include "/libs/uniform.glsl"
#include "/libs/common.glsl"
/*
void FsrEasuCon(out vec4 con0, out vec4 con1, out vec4 con2, out vec4 con3,
// This the rendered image resolution being upscaled
in float inputViewportInPixelsX,
in float inputViewportInPixelsY,
// This is the resolution of the resource containing the input image (useful for dynamic resolution)
in float inputSizeInPixelsX,
in float inputSizeInPixelsY,
// This is the display resolution which the input image gets upscaled to
in float outputSizeInPixelsX,
in float outputSizeInPixelsY) {
    // Output integer position to a pixel position in viewport.
    vec2 invOutputSize = 1.0 / vec2(outputSizeInPixelsX, outputSizeInPixelsY);
    vec2 invInputSize = 1.0 / vec2(inputSizeInPixelsX, inputSizeInPixelsY);

    con0.x = inputViewportInPixelsX * invOutputSize.x;
    con0.y = inputViewportInPixelsY * invOutputSize.y;
    con0.z = 0.5 * inputViewportInPixelsX * invOutputSize.x - 0.5;
    con0.w = 0.5 * inputViewportInPixelsY * invOutputSize.y - 0.5;
    // Viewport pixel position to normalized image space.
    // This is used to get upper-left of 'F' tap.
    con1.x = invInputSize.x;
    con1.y = invInputSize.y;
    // Centers of gather4, first offset from upper-left of 'F'.
    //      +---+---+
    //      |   |   |
    //      +--(0)--+
    //      | b | c |
    //  +---F---+---+---+
    //  | e | f | g | h |
    //  +--(1)--+--(2)--+
    //  | i | j | k | l |
    //  +---+---+---+---+
    //      | n | o |
    //      +--(3)--+
    //      |   |   |
    //      +---+---+
    con1.z =  1.0 * invInputSize.x;
    con1.w = -1.0 * invInputSize.y;
    // These are from (0) instead of 'F'.
    con2.x = -1.0 * invInputSize.x;
    con2.y =  2.0 * invInputSize.y;
    con2.z =  1.0 * invInputSize.x;
    con2.w =  2.0 * invInputSize.y;

    con3.x = 0.0 * invInputSize.x;
    con3.y = 4.0 * invInputSize.y;
    con3.z = 0.0;
    con3.w = 0.0;
}

void FsrEasuF(
out vec3 pix,
vec2 coord, // Integer pixel position in output.
vec4 con0, // Constants generated by FsrEasuCon().
vec4 con1,
vec4 con2,
vec4 con3){
    vec2 ip = floor(coord * resolution);

    //------------------------------------------------------------------------------------------------------------------------------
    // Get position of 'f'.
    vec2 pp = ip * con0.xy + con0.zw;
    vec2 fp = floor(pp);
    pp -= fp;
    //------------------------------------------------------------------------------------------------------------------------------
    // 12-tap kernel.
    //    b c
    //  e f g h
    //  i j k l
    //    n o
    // Gather 4 ordering.
    //  a b
    //  r g
    // For packed FP16, need either {rg} or {ab} so using the following setup for gather in all versions,
    //    a b    <- unused (z)
    //    r g
    //  a b a b
    //  r g r g
    //    a b
    //    r g    <- unused (z)
    // Allowing dead-code removal to remove the 'z's.
    vec2 p0=fp*(con1.xy)+(con1.zw);
    // These are from p0 to avoid pulling two constants on pre-Navi hardware.
    vec2 p1=p0+(con2.xy);       
    vec2 p2=p0+(con2.zw);
    vec2 p3=p0+(con3.xy);
    vec4 bczzR=FsrEasuRF(p0);   //textureGather
    vec4 bczzG=FsrEasuGF(p0);
    vec4 bczzB=FsrEasuBF(p0);
    vec4 ijfeR=FsrEasuRF(p1);
    vec4 ijfeG=FsrEasuGF(p1);
    vec4 ijfeB=FsrEasuBF(p1);
    vec4 klhgR=FsrEasuRF(p2);
    vec4 klhgG=FsrEasuGF(p2);
    vec4 klhgB=FsrEasuBF(p2);
    vec4 zzonR=FsrEasuRF(p3);
    vec4 zzonG=FsrEasuGF(p3);
    vec4 zzonB=FsrEasuBF(p3);
    //------------------------------------------------------------------------------------------------------------------------------
    // Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).
    vec4 bczzL=bczzB*vec4(0.5)+(bczzR*vec4(0.5)+bczzG);
    vec4 ijfeL=ijfeB*vec4(0.5)+(ijfeR*vec4(0.5)+ijfeG);
    vec4 klhgL=klhgB*vec4(0.5)+(klhgR*vec4(0.5)+klhgG);
    vec4 zzonL=zzonB*vec4(0.5)+(zzonR*vec4(0.5)+zzonG);
    // Rename.
    float bL=bczzL.x;
    float cL=bczzL.y;
    float iL=ijfeL.x;
    float jL=ijfeL.y;
    float fL=ijfeL.z;
    float eL=ijfeL.w;
    float kL=klhgL.x;
    float lL=klhgL.y;
    float hL=klhgL.z;
    float gL=klhgL.w;
    float oL=zzonL.z;
    float nL=zzonL.w;
    // Accumulate for bilinear interpolation.
    vec2 dir=(0.0);
    float len=(0.0);
    FsrEasuSetF(dir,len,pp,true, false,false,false,bL,eL,fL,gL,jL);
    FsrEasuSetF(dir,len,pp,false,true ,false,false,cL,fL,gL,hL,kL);
    FsrEasuSetF(dir,len,pp,false,false,true ,false,fL,iL,jL,kL,nL);
    FsrEasuSetF(dir,len,pp,false,false,false,true ,gL,jL,kL,lL,oL);
    //------------------------------------------------------------------------------------------------------------------------------
    // Normalize with approximation, and cleanup close to zero.
    vec2 dir2=dir*dir;
    float dirR=dir2.x+dir2.y;
    AP1 zro=dirR<(1.0/32768.0);
    dirR=(1.0 / dirR);
    dirR=zro?(1.0):dirR;
    dir.x=zro?(1.0):dir.x;
    dir*=(dirR);
    // Transform from {0 to 2} to {0 to 1} range, and shape with square.
    len=len*(0.5);
    len*=len;
    // Stretch kernel {1.0 vert|horz, to sqrt(2.0) on diagonal}.
    float stretch = (dir.x*dir.x+dir.y*dir.y) * (1.0 / max(abs(dir.x), abs(dir.y)));
    // Anisotropic length after rotation,
    //  x := 1.0 lerp to 'stretch' on edges
    //  y := 1.0 lerp to 2x on edges
    vec2 len2 = vec2((1.0) + (stretch - (1.0)) * len, 1.0 + -0.5 * len);
    // Based on the amount of 'edge',
    // the window shifts from +/-{sqrt(2.0) to slightly beyond 2.0}.
    float lob = (0.5)+((1.0/4.0-0.04)-0.5) * len;
    // Set distance^2 clipping point to the end of the adjustable window.
    float clp = 1.0 / lob;
    //------------------------------------------------------------------------------------------------------------------------------
    // Accumulation mixed with min/max of 4 nearest.
    //    b c
    //  e f g h
    //  i j k l
    //    n o
    vec3 min4=min(min(vec3(ijfeR.z,ijfeG.z,ijfeB.z),vec3(klhgR.w,klhgG.w,klhgB.w),vec3(ijfeR.y,ijfeG.y,ijfeB.y)),
                vec3(klhgR.x,klhgG.x,klhgB.x));
    vec3 max4=max(max(vec3(ijfeR.z,ijfeG.z,ijfeB.z),vec3(klhgR.w,klhgG.w,klhgB.w),vec3(ijfeR.y,ijfeG.y,ijfeB.y)),
                vec3(klhgR.x,klhgG.x,klhgB.x));
    // Accumulation.
    vec3 aC=vec3(0.0);
    float aW=(0.0);
    FsrEasuTapF(aC,aW,vec2( 0.0,-1.0)-pp,dir,len2,lob,clp,vec3(bczzR.x,bczzG.x,bczzB.x)); // b
    FsrEasuTapF(aC,aW,vec2( 1.0,-1.0)-pp,dir,len2,lob,clp,vec3(bczzR.y,bczzG.y,bczzB.y)); // c
    FsrEasuTapF(aC,aW,vec2(-1.0, 1.0)-pp,dir,len2,lob,clp,vec3(ijfeR.x,ijfeG.x,ijfeB.x)); // i
    FsrEasuTapF(aC,aW,vec2( 0.0, 1.0)-pp,dir,len2,lob,clp,vec3(ijfeR.y,ijfeG.y,ijfeB.y)); // j
    FsrEasuTapF(aC,aW,vec2( 0.0, 0.0)-pp,dir,len2,lob,clp,vec3(ijfeR.z,ijfeG.z,ijfeB.z)); // f
    FsrEasuTapF(aC,aW,vec2(-1.0, 0.0)-pp,dir,len2,lob,clp,vec3(ijfeR.w,ijfeG.w,ijfeB.w)); // e
    FsrEasuTapF(aC,aW,vec2( 1.0, 1.0)-pp,dir,len2,lob,clp,vec3(klhgR.x,klhgG.x,klhgB.x)); // k
    FsrEasuTapF(aC,aW,vec2( 2.0, 1.0)-pp,dir,len2,lob,clp,vec3(klhgR.y,klhgG.y,klhgB.y)); // l
    FsrEasuTapF(aC,aW,vec2( 2.0, 0.0)-pp,dir,len2,lob,clp,vec3(klhgR.z,klhgG.z,klhgB.z)); // h
    FsrEasuTapF(aC,aW,vec2( 1.0, 0.0)-pp,dir,len2,lob,clp,vec3(klhgR.w,klhgG.w,klhgB.w)); // g
    FsrEasuTapF(aC,aW,vec2( 1.0, 2.0)-pp,dir,len2,lob,clp,vec3(zzonR.z,zzonG.z,zzonB.z)); // o
    FsrEasuTapF(aC,aW,vec2( 0.0, 2.0)-pp,dir,len2,lob,clp,vec3(zzonR.w,zzonG.w,zzonB.w)); // n
    //------------------------------------------------------------------------------------------------------------------------------
    // Normalize and dering.
    pix=min(max4,max(min4,aC*vec3(1.0 / aW)));
}
*/

vec3 RGBToYCoCg(vec3 c) {
	// Y = R/4 + G/2 + B/4
	// Co = R/2 - B/2
	// Cg = -R/4 + G/2 - B/4

    return vec3(c.x/4.0 + c.y/2.0 + c.z/4.0,
                c.x/2.0 - c.z/2.0,
                -c.x/4.0 + c.y/2.0 - c.z/4.0);
}

vec3 YCoCgToRGB(vec3 c) {
	// R = Y + Co - Cg
	// G = Y + Cg
	// B = Y - Co - Cg

    return vec3(c.x + c.y - c.z,
             c.x + c.z,
	         c.x - c.y - c.z);
}

vec4 ReprojectSampler(in sampler2D tex, in vec2 pixelPos){
    vec4 result = vec4(0.0);

    vec2 position = resolution * pixelPos;
    vec2 centerPosition = floor(position - 0.5) + 0.5;

    vec2 f = position - centerPosition;
    vec2 f2 = f * f;
    vec2 f3 = f * f2;

    float c = 0.5;
    vec2 w0 =         -c  *  f3 + 2.0 * c          *  f2 - c  *  f;
    vec2 w1 =  (2.0 - c)  *  f3 - (3.0 - c)        *  f2            + 1.0;
    vec2 w2 = -(2.0 - c)  *  f3 + (3.0 - 2.0 * c)  *  f2 + c  *  f;
    vec2 w3 =          c  *  f3 - c                *  f2;
    vec2 w12 = w1 + w2;

    vec2 tc12 = texelSize * (centerPosition + w2 / w12);
    vec2 tc0 = texelSize * (centerPosition - 1.0);
    vec2 tc3 = texelSize * (centerPosition + 2.0);

    result =  vec4(texture(tex, vec2(tc12.x, tc0.y)).rgb, 1.0) * (w12.x * w0.y) +
              vec4(texture(tex, vec2(tc0.x, tc12.y)).rgb, 1.0) * (w0.x * w12.y) +
              vec4(texture(tex, vec2(tc12.x, tc12.y)).rgb, 1.0) * (w12.x * w12.y) +
              vec4(texture(tex, vec2(tc3.x, tc12.y)).rgb, 1.0) * (w3.x * w12.y) +
              vec4(texture(tex, vec2(tc12.x, tc3.y)).rgb, 1.0) * (w12.x * w3.y);

    result /= result.a;
    result.rgb = saturate(result.rgb);

    return result;
}

vec3 GetVariance(in vec2 coord, out vec3 minColor, out vec3 maxColor) {
    vec3 m1 = vec3(0.0);
    vec3 m2 = vec3(0.0);

    for(float i = -1.0; i <= 1.0; i += 1.0) {
        for(float j = -1.0; j <= 1.0; j += 1.0) {
            vec3 sampleColor = RGBToYCoCg(texture(composite, coord + vec2(i, j) * texelSize).rgb);

            m1 += sampleColor;
            m2 += sampleColor * sampleColor;
        }
    }

    m1 /= 9.0;
    m2 /= 9.0;

    vec3 variance = sqrt(abs(m1 * m1 - m2));

    const float sigma = 2.0;

    minColor = m1 - variance * sigma;
    maxColor = m1 + variance * sigma;

    return variance;
}

vec3 GetClosest(in vec2 coord) {
    vec3 closest = vec3(0.0, 0.0, 1.0);

    for(float i = -1.0; i <= 1.0; i += 1.0) {
        for(float j = -1.0; j <= 1.0; j += 1.0) {
            float depth = texture(depthtex0, coord + vec2(i, j) * texelSize).x;

            if(depth < closest.z) {
                closest = vec3(i, j, depth);
            }
        }
    }

    closest.xy = closest.xy * texelSize + coord;

    return closest;
}

void main() {
    vec3 color = RGBToYCoCg(texture(composite, texcoord).rgb);

    vec3 maxColor = vec3(1.0);
    vec3 minColor = vec3(0.0);
    vec3 variance = GetVariance(texcoord, minColor, maxColor);

    vec3 closest = GetClosest(texcoord);
    vec2 velocity = GetVelocity(closest);
    if(closest.z < 0.7) velocity *= 0.001;

    vec2 previousCoord = texcoord - velocity;
    float InScreen = step(max(abs(previousCoord.x - 0.5), abs(previousCoord.y - 0.5)), 0.5);

    vec3 previousColor = RGBToYCoCg(ReprojectSampler(colortex7, previousCoord).rgb);
         previousColor = clamp(previousColor, minColor, maxColor);

    vec3 antialiased = mix(color, previousColor, 0.95 * InScreen);

    gl_FragData[0] = vec4(YCoCgToRGB(antialiased), 1.0);
    gl_FragData[1] = vec4(YCoCgToRGB(antialiased), 1.0);
}
/* DRAWBUFFERS:37 */